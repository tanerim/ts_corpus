##################################
# coding: utf-8
# Turkish Word2vec Graph Network
# Author Taner Sezer
##################################
import os
import sys
import networkx as nx
from pyvis.network import Network
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import re
# Libraries for FastText
from pyfasttext import FastText
from nxviz.plots import ArcPlot
# Libraries for API
import pycurl
import simplejson as json
import requests
from urllib.parse import urlencode
from urllib.request import Request, urlopen

# Get values from cli
# The keyword
f = sys.argv[1]
key = str(f)
# Coverage of the network
g = sys.argv[2]
level = int(g)
# The model
h = sys.argv[3]
model = FastText(h)
# Graph Physics
net_type = str(sys.argv[4])
# Set Edge Type
edge_type = str(sys.argv[5])
# Set Edge Color
e_color = str(sys.argv[6])
# Arrow Direction
a_direction = str(sys.argv[7])


# Punctuatinos for stripping
punctuations = '''!()-[]{};:'"\\,<>./?@#$%^&*_~'''

# API values
url = 'https://nlp.tscorpus.com/api/parser/'
headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}
r = requests.post(url, headers)


# Clean data from API return
def satirla(girdi):
    satirla = girdi.replace("],[", "]\n[")
    return satirla

# Clean data from API return


def replace(girdi):
    cikti = girdi.strip(punctuations)
    temiz = cikti.replace('\",\"', ",")
    return temiz

# Lemmatization API Function


def lemma(girdi):
    istek = {"text": girdi, "fields": "lemma"}
    lemmas = ((requests.post(url, istek, headers)).text)
    sonuc = lemmas.strip(punctuations)
    cikti = re.sub(r'^.*\"', '', sonuc)
    if cikti == "No_Lemma":
        cikti = girdi
    else:
        cikti == sonuc
    return cikti


# Load model and set query key
primary = (model.nearest_neighbors(key, k=25))

my_dict = dict(primary)

# Empty list for first cycle
f_cycle = []
f_second_input = []
# Create first cycle data
for word, weight in my_dict.items():
    word = word.lower()
    weight = format(weight, '.3f')
    if word != key and not word.startswith(key):
        word = lemma(word)
        f_second_input.append(word)
        # sonuc = (f"{key},{word},{weight}")
        sonuc = key, word, weight
        f_cycle.append(sonuc)

# Empty list for second cycle
s_cycle = []
# Create second cycle data
# Get secondary NN values generated by main values
for item in f_second_input:
    secondary = (model.nearest_neighbors(item, k=25))
    for s_word, s_weight in secondary:
        s_word = s_word.lower()
        s_weight = float(format(s_weight, '.3f'))
        if s_word != item and not s_word.startswith(item):
            s_word = lemma(s_word)
            # hits = (f"{keys},{s_word},{s_weight}")
            hits = item, s_word, str(s_weight)
            s_cycle.append(hits)

# print("First_Cycle:", f_cycle)
# print("Second_Cycle:", s_cycle)

# Join first and second NN Values
if level == 1:
    final = f_cycle
if level == 2:
    final = f_cycle + s_cycle
# print(first)
print(final)

# Create pandas DataFrame
my_obj = pd.DataFrame(final, columns=["Source", "Target", "Weight"])

# Write Pandas DataFrame as csv file
my_obj.to_csv(key+'.csv', encoding='utf-8', index=False)

# Write Pandass DataFrame as json file
# my_obj.to_json(key+".json")

# Create Network Graph/
ts_net = Network(height="100%", width="100%",
                 bgcolor="#222222", font_color="white")

# set the physics layout of the network
# ts_net.repulsion(damping=0.9, spring_length=200, node_distance=350)
if net_type == "atlas":
    ts_net.force_atlas_2based(gravity=-50, central_gravity=0.01,
                              spring_length=100, spring_strength=0.08, damping=0.4, overlap=0)
if net_type == "barnes":
    ts_net.barnes_hut(gravity=-80000, central_gravity=0.3,
                      spring_length=25, spring_strength=0.001, damping=0.09, overlap=0)
if net_type == "repulsion":
    ts_net.repulsion(damping=0.9, spring_length=200, node_distance=350)
if net_type == "hrepulsion":
    ts_net.hrepulsion(node_distance=120, central_gravity=0.0,
                      spring_length=100, spring_strength=0.01, damping=0.09)

ts_data = pd.read_csv(key+".csv")

# Call Columns in csv File by Column Names
sources = ts_data['Source']
targets = ts_data['Target']
weights = ts_data['Weight']

edge_data = zip(sources, targets, weights)


# add edge data
for e in edge_data:
    src = e[0]
    dst = e[1]
    w = e[2]

    ts_net.add_node(src, src, title=src, shape="box",
                    color="orange", shadow="true", selfReferenceSize=0)
    ts_net.add_node(dst, dst, title=dst, shape="dot", color=e_color)
    ts_net.add_edge(src, dst, value=w, arrows=a_direction, color="rgb(25,180,5)",
                    selfReferenceSize=0, selectionWidth=0.1, shadow="true")

# ts_net.show_buttons(filter_=['physics'])
neighbor_map = ts_net.get_adj_list()

# Set curve Type
if edge_type == "curvedCW":
    ts_net.set_edge_smooth("CurvedCW")
elif net_type == "curvedCCW":
    ts_net.set_edge_smooth("CurvedCCW")
elif net_type == "cubicBezier":
    ts_net.set_edge_smooth("cubicBezier")
elif net_type == "diagonalCross":
    ts_net.set_edge_smooth("diagonalCross")
elif net_type == "straightCross":
    ts_net.set_edge_smooth("straightCross")
elif net_type == "dynamic":
    ts_net.set_edge_smooth("dynamic")
elif net_type == "continuous":
    ts_net.set_edge_smooth("continuous")
elif net_type == "discrete":
    ts_net.set_edge_smooth("discrete")
# add neighbor data to node hover data
for node in ts_net.nodes:
    node["title"] += " Neighbors:<br>" + "<br>".join(neighbor_map[node["id"]])
    node["value"] = len(neighbor_map[node["id"]])

# Generate HTML file and trigger browser
# ts_net.show_buttons()
# ts_net.write_html(key+".html")
ts_net.show(key+".html")
